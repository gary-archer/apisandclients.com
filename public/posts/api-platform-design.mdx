# API Platform Overview

Previously I completed this blog’s SPA theme with some <Link href='/posts/reactjs-codingkeypoints'>Final SPA Code Details</Link>. Next, I summarise what I consider to be the most essential technical behaviours for a platform of many APIs in an OAuth architecture.

### API Technical Goals

There are many technical goals you might articulate for an API platform. In this post I focus only on the following qualities:

| Behaviour | Description |
| --------- | ----------- |
| Productive | The overall design reduces complexity and encourages a business focus for most API work. |
| Secure | APIs implement security in the same way for requests from any type of client, with low-level security externalised. |
| Supportable | Errors or slowness can be diagnosed quickly in most cases, due to solid logging and error handling designs. |
| Scalable | Design patterns can scale across many APIs, clients and development teams. |

### Components

The API flows in this blog serve web and mobile clients and consist of the following components. This type of separation externalizes most security behaviors from application code and also provides applications with the best security features:

| Component Type | Key Behaviour |
| -------------- | ------------- |
| Single Page Application | Clients that follow browser best practices and use cookies to transport access tokens to APIs. |
| Native Application | Desktop and mobile clients that follow native best practices and call APIs with access tokens. |
| API | APIs receive secure values in JWT access tokens and use them for business authorizion. |
| API Gateway | The API gateway handles client-specific security differences, to handle concerns like cookies, CORS and CSRF for web clients. |
| Authorization Server | The main security component that issues access tokens and implements user authentication. |
| Log Aggregation System | Captures API logs and enables people to make sense of API activity under load. |

### Scalable API Security

Each API should perform the following steps to securely handle incoming requests. You can then expose any API endpoint to the internet, to maximise business value:

- <Link href='/posts/jwt-access-token-validation'>JWT Access Token Validation</Link>
- <Link href='/posts/api-authorization-design'>Claims Based Authorization</Link>

The API security architecture is scalable if you can add more clients and APIs without adding overall complexity. In OAuth, you need to scale your use of *scopes and claims* and avoid manageability problems.

APIs should also call each other securely, using either synchronous or asynchronous requests. In either case it is desirable to flow the user identity and other claims in a verifiable way, by sharing a JWT access token. OAuth gives you design patterns to help enable this.

### Authorization Server

This is the key security component, and you should choose one that provides the following capabilities:

| Capabilities | Description |
| ------------ | ----------- |
| Support for Standards | There should be up-to-date support for many security standards, which map to your use cases. This includes recent authentication methods. |
| Extensibility | It must be possible to take control over core behaviours and user attributes, so that you can authenticate users in your preferred ways and then issue your preferred access tokens. |
| Reliability | The authorization server is a critical component. It should therefore align with your API deployments and have good troubleshooting support, to enable fast incident resolution. |

### Observability

Since OAuth is a distributed architecture, you need solid approaches to logging, error handling and technical support. You then have confidence that the system runs reliably. Therefore this blog takes particular care over the following areas, using third-party components that provide the best visibility:

- <Link href='/posts/effective-api-logging'>Effective API Logging</Link>
- <Link href='/posts/error-handling-and-supportability'>Error Handling and Supportability</Link>
- <Link href='/posts/api-technical-support-analysis'>Technical Support Analysis</Link>

### Final APIs

I provide 3 final REST APIs whose code is almost identical. Each API uses both *core identity user attributes* and *volatile business user attributes*, so that each API could evolve its use of claims in future. The APIs also implement the above observability behaviours.

- <Link href='/posts/api-architecture-node'>Node.js API</Link>
- <Link href='/posts/net-core-code-sample-overview'>.NET API</Link>
- <Link href='/posts/java-spring-boot-api-overview'>Java API</Link>



### Cloud Hosting

This blog uses portable design patterns that work for any type of deployment. I use <Link href='/posts/cloud-hosting'>Serverless Hosting</Link> for some deployed API components, to minimise my personal hosting costs. Yet the final APIs are cloud native and can run in platforms like Kubernetes, where you can use best-of-breed supporting components for APIs.

In all cases though, I use different hosting for the web and API sides of the architecture. The web side of the architecture is only static content and is deployed to many global locations by a low cost content delivery network. The API side of the architecture is more intricate so I prefer to run it wherever the API supporting components provide the best capabilities.

### Where Are We?

I have summarised some foundations to aim for when designing a modern API platform. In this blog’s second theme I demonstrate some techniques for meeting my API requirements.

### Next

- I describe an <Link href='/posts/api-journey-server-side'>API Journey – Server Side</Link>.
- For a list of all blog posts see the <Link href='/posts/index'>Index Page</Link>.
