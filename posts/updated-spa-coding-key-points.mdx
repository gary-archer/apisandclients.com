# Updated SPA – Code Overview

In the previous post I described the behaviour of the <Link href='/posts/improved-spa-code-sample-overview'>Updated SPA and API Code Sample</Link>. Next I summarize some changes to the SPA code.

### SPA OAuth Configuration Changes

I use additional settings from the *oidc-client-ts* library to use the following features in the SPA:

- In-memory token storage.
- Silent token renewal via Iframes.
- Logout.

The authenticator class therefore uses additional oidc-client-ts settings:

```typescript
public constructor(configuration: OAuthConfiguration) {

    this._configuration = configuration;
    const settings = {

        authority: configuration.authority,
        client_id: configuration.clientId,
        redirect_uri: configuration.redirectUri,
        scope: configuration.scope,
        response_type: 'code',
        userStore: new WebStorageStateStore({ store: new InMemoryWebStorage() }),
        stateStore: new WebStorageStateStore({ store: sessionStorage }),

        silent_redirect_uri: configuration.redirectUri,
        automaticSilentRenew: false,
        loadUserInfo: false,
        post_logout_redirect_uri: configuration.postLogoutRedirectUri,
    };

    this._userManager = new UserManager(settings);
}
```

### Enabling IFrame Renewal

The final SPA uses a couple of security behaviours that no longer align with security best practices:

| Behaviour | Description |
| --------- | ----------- |
| <span style={{color:'red'}}>Refresh Tokens in the Browser.</span> | The AWS Cognito authorization server returns refresh tokens to the browser, which should not be done when using this flow. |
| <span style={{color:'red'}}>Access Tokens in the Browser.</span> | These days you should also avoid returning access tokens to the browser due to XSS threats. |

With AWS Cognito there are also some reliability problems with iframe token renewal. To provide a working and reliable solution, the SPA uses the refresh token to renew access tokens when the provider is AWS Cognito. Since I store the refresh token in-memory, there is an OpenID Connect redirect whenever the browser page is reloaded.

To activate iframe based token renewal, simply set a different provider name in the SPA’s configuration file. Then run options such as refreshing the browser page to understand the problems:

```json
{
    "app": {
        "apiBaseUrl":             "https://api.authsamples-dev.com/api"
    },
    "oauth": {
        "provider":               "cognito",
        "authority":              "https://cognito-idp.eu-west-2.amazonaws.com/eu-west-2_CuhLeqiE9",
        "clientId":               "hje94a2jj3lgkobkh57ikenhh",
        "redirectUri":            "https://www.authsamples-dev.com/spa",
        "postLogoutRedirectUri":  "https://www.authsamples-dev.com/spa/loggedout.html",
        "scope":                  "openid profile https://api.authsamples.com/investments",
        "customLogoutEndpoint":   "https://login.authsamples.com/logout"
    }
}
```

Yet the code sample is intended to demonstrate iframe-based token renewal and behaves this way if points to an authorization server that supports the correct behaviour. Therefore, I describe the intended behavior next.

### Silent Token Renewal Implementation

The SPA consists of a main window and a dynamic iframe that implements iframe redirects. JavaScript applications run on both of these windows, yet I want to avoid the need for separate HTML files or JavaScript bundles for the iframe application. Therefore, the entry point *index.ts* file now contains the following code, to detect whether the frame or top level window runs:

```typescript
if (window.top === window.self) {

    const app = new App();
    app.execute();

} else {

    const app = new IFrameApp();
    app.execute();
}
```

Initially, the iframe app does not exist. The main window creates it when it initiates token renewal. The oidc-client-ts library spins up an iframe and runs an authorization code flow with PKCE, using the OpenID Connect *prompt=none* parameter:

```typescript
private async _performAccessTokenRenewalViaIframeRedirect(): Promise<void> {

    try {

        await this._userManager.signinSilent();

    } catch (e: any) {

        if (e.error === ErrorCodes.loginRequired) {

            await this.clearLoginState();

        } else {

            throw ErrorFactory.getFromTokenError(e, ErrorCodes.tokenRenewalError);
        }
    }
}
```

My *IFrameApp* class gets instantiated when the authorization server redirects the iframe back to the SPA, which receives a response URL of the following form, containing the authorization code:

- *https://www.authsamples-dev.com/spa?code=xxx&state=yyy*

The job of the iframe app is to POST the response URL to the SPA’s main window, which then exchanges the code for tokens. The tokens are then stored in-memory.

```typescript
export class IFrameApp {

    public async execute(): Promise<void> {

        try {

            const args = new URLSearchParams(location.search);
            const state = args.get('state');
            if (state) {

                const configuration = await ConfigurationLoader.download('spa.config.json');
                const settings = {
                    authority: configuration.oauth.authority,
                    client_id: configuration.oauth.clientId,
                    redirect_uri: configuration.oauth.redirectUri,
                };

                const userManager = new UserManager(settings);
                await userManager.signinSilentCallback();
            }

        } catch (e: any) {

            const uiError = ErrorFactory.getFromTokenError(e, ErrorCodes.tokenRenewalError);
            ErrorConsoleReporter.output(uiError);
        }
    }
}
```

### Security Library Behaviour

The oidc-client-ts library uses the [PostMessage API](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage) to send the authorization response URL from the iframe to the main window. You can use code such as the following to intercept the posted message and view the data:

```typescript
window.addEventListener('message', (evt) => {
  console.log(evt);
});
```

When the main window exchanges the code for token it uses the PKCE *code_verifier* that was saved to session storage before the iframe redirect. You can view the oidc-client-ts library’s logging output, including validation of received tokens. To do so, append *#log=debug* to the SPA URL, and also ensure that the browser console tools use the *Preserve Log* and *All Levels* options:

![oidc browser logs](/images/180/oidc-browser-logs.jpg?v=20240813)

### SPA Basic Logout

To implement logout I remove tokens from the app and then perform an OpenID Connect RP-initiated logout to remove the SSO cookie. The oidc-client-ts library does this in a one-liner. Yet AWS Cognito, like some other authorization servers, has vendor-specific logout behavior. The SPA therefore has to implement a workaround, which is an annoyance.

```typescript
public async startLogout(): Promise<void> {

    try {

        await this.clearLoginState();
        HtmlStorageHelper.raiseLoggedOutEvent();

        if (this._configuration.provider === 'cognito') {

            location.replace(this._getCognitoEndSessionRequestUrl());

        } else {

            await this._userManager.signoutRedirect();
        }
    }
}
```

### SPA Multi Tab Logout

The sample also supports multi-tab logout, described in the earlier <Link href='/posts/logout'>Logout</Link> post. Rather than attempting to use single-logout solutions that send the SSO cookie from iframes, the SPA simply watches an *isLoggedOut* boolean in local storage, using the [Browser Storage API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API).

If a user runs multiple tabs and signs out on one of them, the following code then run in all other tabs, each of which simply removes its tokens and redirects the user to the logged out view.

```typescript
private _onStorageChange(event: StorageEvent): void {

    if (HtmlStorageHelper.isLoggedOutEvent(event)) {

        this._authenticator!.onExternalLogout();
        location.hash = '#loggedout';
    }
}
```

### SPA Calls API to get User Info

Finally, the SPA gets name details from the authorization server's OpenID Connect userinfo endpoint, and some secondary user attributes from the API, then displays both together in the top right of the view:

```typescript
public async load(authenticator: Authenticator, apiClient: ApiClient): Promise<void> {

    const oauthUserInfo = await authenticator.getUserInfo();
    const apiUserInfo = await apiClient.getUserInfo();

    if (oauthUserInfo && apiUserInfo) {

        const viewModel = {
            userName: this.getUserNameForDisplay(oauthUserInfo),
            title: this.getUserTitle(apiUserInfo),
            regions: this.getUserRegions(apiUserInfo),
        };

        const htmlTemplate =
            `<div class='text-end mx-auto'>
                <div class='fw-bold basictooltip'>{{userName}}
                    <div class='basictooltiptext'>
                        <small>{{title}}</small>
                        <br />
                        <small>{{regions}}</small>
                    </div>
                </div>
            </div>`;

        const html = mustache.render(htmlTemplate, viewModel);
        DomUtils.html('#username', html);
    }
}
```

### Where Are We?

I explained the code to complete the traditional SPA flow, with in-memory storage of access tokens, and the SSO cookie used for token refresh.

### Next

- Next I provide an <Link href='/posts/updated-api-coding-key-points'>Updated API Code Overview</Link>.
- For a list of all blog posts see the <Link href='/posts/index'>Index Page</Link>.
