# How to Run the iOS Code Sample

Previously we provided an an <Link href='/posts/ios-code-sample-overview'>iOS Code Sample Overview</Link> and next we will describe how to run and test the code sample. For details on getting started with AppAuth libraries, and tracing OAuth requests, see these earlier pages:

- <Link href='/posts/ios-setup'>iOS Setup and the AppAuth Sample</Link>
- <Link href='/posts/ios-https-debugging'>iOS HTTPS Debugging</Link>

### Prerequisite 1: Install Xcode

Use an up to date version of Xcode on your macOS system, so that you have access to the latest Swift and Swift UI features.

### Prerequisite 2: Install SwiftLint

This is used to make *code quality checks* and runs as a build step, so it is needed to compile our code sample. Download and run the PKG file for the latest version from the [SwiftLint Releases Page](https://github.com/realm/SwiftLint/releases).

### Step 1: Download the Code

The project is available [here](https://github.com/gary-archer/oauth.mobilesample.ios), and can be downloaded / cloned to your local PC with the following command:

```bash
git clone https://github.com/gary-archer/oauth.mobilesample.ios
```

![repo](/images/550/repo.jpg)

### Step 2: Open the Project in Xcode

In Xcode the project layout looks as follows, and our Swift code is under the *Source* folder. I used techniques from [this link](https://stevenpcurtis.medium.com/how-to-structure-your-folders-in-xcode-fbb1afa50bc7) to control the folder layout.

![project layout](/images/550/project-layout.jpg)

You should be able to run the app on a simulator without any special *Signing & Capabilities* requirements, as shown here:

![emulator settings](/images/550/simulator-settings.jpg)

### Step 3: Understand Dependencies

We are using the following external dependencies:

| Library | Usage |
| ------- | ----- |
| <span style={{color:'green'}}>**AppAuth**</span> | Does the OAuth based authentication work for the app |
| <span style={{color:'green'}}>**Swift Keychain Wrapper**</span> | Simplifies secure storage of OAuth tokens on devices |

These references were added via the *Swift Package Manager* and are built as libraries:

![dependencies](/images/550/dependencies.jpg)

I then linked with the built libraries from the following page:

![library linking](/images/550/library-linking.jpg)

### Step 4: Run the App on a Simulator

You can now run our demo app via the *Run* icon in the Xcode toolbar. You may then get an initial prompt to *Secure your Device*, after which you will be able to login with the following test credential:

- User: *guestuser`@`mycompany.com*
- Password: *GuestPassword1*

Next save the password when prompted, then navigate between views by clicking an item in the companies view or using the *Home* button:

![running app](/images/550/running-app.jpg)

### Step 5: Understand Configuration Settings

When our app runs it uses the API and OAuth settings from an embedded JSON configuration file:

```json
{
  "app": {
    "apiBaseUrl":             "https://api.authsamples.com/investments"
  },
  "oauth": {
    "authority":              "https://cognito-idp.eu-west-2.amazonaws.com/eu-west-2_CuhLeqiE9",
    "userInfoEndpoint":       "https://login.authsamples.com/oauth2/userInfo",
    "clientId":               "2vshs4gidsbpnjmsprhh607ege",
    "webBaseUrl":             "https://authsamples.com",
    "loginRedirectPath":      "/apps/basicmobileapp/postlogin.html",
    "postLogoutRedirectPath": "/apps/basicmobileapp/postlogout.html",
    "deepLinkBaseUrl":        "https://mobile.authsamples.com",
    "loginActivatePath":      "/basicmobileapp/oauth/callback",
    "postLogoutActivatePath": "/basicmobileapp/oauth/logoutcallback",
    "scope":                  "openid profile email https://api.authsamples.com/investments",
    "customLogoutEndpoint":   "https://login.authsamples.com/logout"
  }
}
```

### Step 6: Understand Login Redirects

By using AppAuth libraries the standard *Authorization Code Flow (PKCE)* message is sent.

![authorization request](/images/550/authorization-request.jpg)

Our AWS Cognito authorization server accepts the request and issues an authorization code because the *Client ID*, *Redirect URI* and *Scope* of the request match those configured in a Cognito OAuth client:

![oauth client 1](/images/550/oauth-client1.jpg)
![oauth client 2](/images/550/oauth-client2.jpg)

### Step 7: Understand Redirect Response Handling

The result of successful authorization is the following message, and note that this is sent to a web domain rather than directly to our iOS app:

![authorization response](/images/550/authorization-response.jpg)

Two interstitial web pages are used with our iOS sample, hosted at the following URLs:

- https`:`//authsamples.com/apps/basicmobileapp/postlogin.html
- https`:`//authsamples.com/apps/basicmobileapp/postlogout.html

If we use the *View Source* option in a desktop browser for one of the above URLs, we can see that they just forward query parameters from the login response using a deep linking URL:

![view source](/images/550/view-source.jpg)

For this to work we need to register the https`:`//mobile.authsamples.com base URL as an *Associated Domain* in the *basicmobileapp.entitlements* file:

![entitlements](/images/550/entitlements.jpg)

Note that if the interstitial page is left for a couple of minutes before the user clicks *Return to the App*, the authorization code could time out, leading to a user error. The user can always retry and recover though.

### Step 8: Understand Login Completion

Once the authorization code is received by the app, it sends an *Authorization Code Grant* request to Cognito’s token endpoint, which returns OAuth tokens in the response:

![authorization code grant](/images/550/authorization-code-grant.jpg)

The token data is then saved to the iOS keychain, which ensures that the data is kept private to this particular mobile app.

### Step 9: Test Login Actions

It is worth performing certain tests while the ASWebAuthenticationSession window is active, to ensure that the app does not throw exceptions or recreate views unnecessarily:

![login](/images/550/login.jpg)

The first of these is to switch away from the app and then reactivate it from its shortcut. Verify that this does not cause any application problems:

![shortcut](/images/550/shortcut.jpg)

Similarly I would recommend changing the screen orientation half way through login and then completing the sign in.

![landscape](/images/550/landscape.jpg)

### Step 10: Test Restarting the App after Login

Restarting the app after a login will just load OAuth tokens from secure storage, and a new login is not required.

### Step 11: Test Deep Linking

While the app is running we can test deep linking on a simulator via a command such as the following. If required our app performs a *login* or *token renewal* before moving to the deep link destination:

```bash
xcrun simctl openurl booted https://mobile.authsamples.com/basicmobileapp/deeplink/company/2
```

### Step 12: Test Access Token Expiry

We can use the *Expire Access Token* and *Reload Data* buttons to cause an invalid token to be sent to the API, resulting in a 401 response:

![access token expiry](/images/550/access-token-expiry.jpg)

After every API call the UI checks for 401 responses, and handles them by getting a new access token. The API request is then retried once with the new token, so that the user session is silently extended. Note that a mobile app is a public client and the refresh token is not protected with a client credential:

![concurrent refresh](/images/550/concurrent-refresh.jpg)

### Step 13: Test Refresh Token Expiry

We can use *Expire Refresh Token* followed by *Reload Data* to simulate the end of a user session, which might occur if a user left the app running overnight:

![refresh token expiry](/images/550/refresh-token-expiry.jpg)

On the next request for data the attempt to renew the access token will fail, and the result of the refresh token grant message will be an *Invalid Grant* response:

![invalid grant](/images/550/invalid-grant.jpg)

This will trigger a login redirect, and the user may be prompted to sign in again, but will experience no errors.

### Step 14: Test Logout

AWS Cognito also uses a vendor specific logout solution and the logout request requires *client_id* and *logout_url* parameters. AppAuth libraries add some other standards-based parameters. The session cookie is successfully removed though, so there is a working logout solution.

![logout request](/images/550/logout-request.jpg)

When logout completes we are returned to the below post logout view within our app. In a real world app you could then test logging in as another user with different settings or permissions.

![new user login](/images/550/new-user-login.jpg)

### Step 15: Test Failure Scenarios

Our mobile app runs multiple views which could fail concurrently, so we implement the same *Error HyperLink Behaviour* as for our earlier React apps. The following examples cause errors that the UI must handle:

| Scenario | Instructions |
| -------- | ------------ |
| <span style={{color:'red'}}>UI Error</span> | Load data normally, then disable the network and click reload, to cause a connectivity exception |
| <span style={{color:'red'}}>API Error</span> | Long press the *Reload* button, which then sends a custom HTTP header to the API to rehearse an API 500 exception |

Our error display looks as follows after concurrent view failures. The user can click a hyperlink to see details, or press the *Home* button to retry:

![error summary](/images/550/error-summary.jpg)

The summary view uses an iOS modal sheet to display a view with error details, which would help to enable fast problem resolution:

![error details](/images/550/error-details.jpg)

### Where Are We?

We have shown how to run this blog’s iOS code sample,  and test its technical behaviour. Next we will drill into the infrastructure needed to enable the use of OAuth claimed HTTPS schemes.

### Next

- Next we will describe some required <Link href='/posts/ios-infrastructure-setup'>iOS Mobile Infrastructure</Link>
- For a list of all blog posts see the <Link href='/posts/index'>Index Page</Link>
